package workload

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog/v2"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
	ctrl "sigs.k8s.io/controller-runtime"
	ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	timeout     = 10 * time.Minute // Maximum time to wait for a condition
	interval    = 10 * time.Second // Interval between checks
	clusterName = "rke"
	namespace   = "bm-osp	"
)

var (
	managementClient ctrlclient.Client
	workloadClient   *kubernetes.Clientset
)

func TestE2E(t *testing.T) {
	RegisterFailHandler(Fail)

	ctrl.SetLogger(klog.Background())

	RunSpecs(t, "caprke2-e2e-new")
}

var _ = BeforeSuite(func() {
	// Load kubeconfig for the management cluster
	cfg, err := clientcmd.BuildConfigFromFlags("", os.Getenv("KUBECONFIG"))
	Expect(err).NotTo(HaveOccurred(), "Failed to load management cluster kubeconfig")

	// Create the management client
	managementClient, err = ctrlclient.New(cfg, ctrlclient.Options{})
	Expect(err).NotTo(HaveOccurred(), "Failed to create management cluster client")

	// Optionally, initialize the workload client
	workloadClient, err = getWorkloadKubeconfig(managementClient, clusterName, namespace)
	Expect(err).NotTo(HaveOccurred(), "Failed to create workload cluster client")
})

// Test 1: Cluster API Endpoint Validation
var _ = Describe("Cluster API Operations", func() {
	It("Should provision cluster with correct API endpoint", func() {
		var cluster clusterv1.Cluster
		Eventually(func() error {
			return managementClient.Get(
				context.TODO(),
				ctrlclient.ObjectKey{Name: clusterName, Namespace: namespace},
				&cluster,
			)
		}, timeout, interval).Should(Succeed())

		// Verify API server endpoint
		Eventually(func() error {
			// cfg, err := clientcmd.RESTConfigFromKubeConfig(kubeconfig)
			// if err != nil {
			// 	return err
			// // }
			// client, err := kubernetes.NewForConfig(	workloadClientet
			// )
			// if err != nil {
			// 	return err
			// }
			_, err := workloadClient.Discovery().ServerVersion()
			return err
		}, 5*time.Minute, 10*time.Second).Should(Succeed())

		// Verify certificate validity
		Eventually(func() error {
			secret := &corev1.Secret{}
			err := managementClient.Get(
				context.TODO(),
				ctrlclient.ObjectKey{
					Name:      fmt.Sprintf("%s-apiserver-cert", clusterName),
					Namespace: namespace,
				},
				secret,
			)
			if err != nil {
				return err
			}
			// Add certificate validation logic here
			return nil
		}, timeout, interval).Should(Succeed())
	})
})

// Test 4: Network Policy Enforcement
var _ = Describe("Network Connectivity", func() {
	It("Should enforce pod-to-pod network connectivity", func() {
		// Create test namespaces
		testNS := &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "network-test"}}
		Expect(workloadClient.CoreV1().Namespaces().Create(context.TODO(), testNS, metav1.CreateOptions{})).To(Succeed())
		defer workloadClient.CoreV1().Namespaces().Delete(context.TODO(), "network-test", metav1.DeleteOptions{})

		// Deploy test pods
		serverPod := createNetworkTestPod("server", "network-test")
		clientPod := createNetworkTestPod("client", "default")

		// Create restrictive network policy
		policy := &networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{Name: "deny-cross-ns", Namespace: "network-test"},
			Spec: networkingv1.NetworkPolicySpec{
				PodSelector: metav1.LabelSelector{},
				Ingress: []networkingv1.NetworkPolicyIngressRule{{
					From: []networkingv1.NetworkPolicyPeer{{
						NamespaceSelector: &metav1.LabelSelector{
							MatchLabels: map[string]string{"kubernetes.io/metadata.name": "network-test"},
						},
					}},
				}},
			},
		}
		_, err := workloadClient.NetworkingV1().NetworkPolicies("network-test").Create(context.TODO(), policy, metav1.CreateOptions{})
		Expect(err).NotTo(HaveOccurred())

		//Verify connectivity
	// 	Eventually(func() error {
	// 		return testNetworkConnectivity(workloadClient, kubeConfig, serverPod /*sourcePod*/, "10.0.0.1")
	// 	}, 2*time.Minute, 10*time.Second).ShouldNot(HaveOccurred(), "Network connectivity test failed")

	// 	// Eventually(func() error {
	// 	// 	return testNetworkConnectivity(clientPod, serverPod.Status.PodIP)
	// 	// }, 2*time.Minute, 5*time.Second).Should(HaveOccurred())

	// 	// Cleanup policy and verify restored connectivity
	// 	Expect(workloadClient.NetworkingV1().NetworkPolicies("network-test").Delete(context.TODO(), "deny-cross-ns", metav1.DeleteOptions{})).To(Succeed())
	// 	Eventually(func() error {
	// 		return testNetworkConnectivity(clientPod, serverPod)
	// 	}, 2*time.Minute, 5*time.Second).Should(Succeed())
	// })
})

// Test 5: CoreDNS Functionality
// var _ = Describe("DNS Resolution", func() {
// 	It("Should maintain CoreDNS resolution capabilities", func() {
// 		// Deploy test pod
// 		pod := createDNSTestPod()
// 		defer workloadClient.CoreV1().Pods("default").Delete(context.TODO(), "dns-test", metav1.DeleteOptions{})

// 		// Test internal resolution
// 		Eventually(func() error {
// 			output, err := execCommandInPod(workloadClient, kubeConfig, "default", "dns-test", []string{"nslookup", "kubernetes.default.svc.cluster.local"})

// 			// Print logs for debugging
// 			GinkgoWriter.Println("Exec Output:", output)

// 			return err
// 		}, 5*time.Minute, 30*time.Second).ShouldNot(HaveOccurred(), "DNS resolution failed")

// 		// Test external resolution
// 		Eventually(func() error {
// 			_, err := workloadClient.CoreV1().Pods("default").Exec(
// 				context.TODO(),
// 				"dns-test",
// 				&corev1.PodExecOptions{
// 					Command: []string{"nslookup", "example.com"},
// 					Stdout:  nil,
// 					Stderr:  nil,
// 				},
// 			)
// 			return err
// 		}, 3*time.Minute, 10*time.Second).Should(Succeed())

// 		// Induce DNS failure and verify recovery
// 		originalDeployment, err := workloadClient.AppsV1().Deployments("kube-system").Get(
// 			context.TODO(),
// 			"coredns",
// 			metav1.GetOptions{},
// 		)
// 		Expect(err).NotTo(HaveOccurred())

// 		// Scale down CoreDNS
// 		originalReplicas := *originalDeployment.Spec.Replicas
// 		scaleDown := int32(0)
// 		originalDeployment.Spec.Replicas = &scaleDown
// 		_, err = workloadClient.AppsV1().Deployments("kube-system").Update(
// 			context.TODO(),
// 			originalDeployment,
// 			metav1.UpdateOptions{},
// 		)
// 		Expect(err).NotTo(HaveOccurred())

// 		// Verify DNS failure
// 		Eventually(func() error {
// 			_, err := workloadClient.CoreV1().Pods("default").Exec(
// 				context.TODO(),
// 				"dns-test",
// 				&corev1.PodExecOptions{
// 					Command: []string{"nslookup", "kubernetes.default.svc.cluster.local"},
// 					Stdout:  nil,
// 					Stderr:  nil,
// 				},
// 			)
// 			return err
// 		}, 5*time.Minute, 30*time.Second).Should(HaveOccurred())

// 		// Restore CoreDNS
// 		originalDeployment.Spec.Replicas = &originalReplicas
// 		_, err = workloadClient.AppsV1().Deployments("kube-system").Update(
// 			context.TODO(),
// 			originalDeployment,
// 			metav1.UpdateOptions{},
// 		)
// 		Expect(err).NotTo(HaveOccurred())

// 		// Verify recovery
// 		Eventually(func() error {
// 			_, err := workloadClient.CoreV1().Pods("default").Exec(
// 				context.TODO(),
// 				"dns-test",
// 				&corev1.PodExecOptions{
// 					Command: []string{"nslookup", "kubernetes.default.svc.cluster.local"},
// 					Stdout:  nil,
// 					Stderr:  nil,
// 				},
// 			)
// 			return err
// 		}, 5*time.Minute, 30*time.Second).Should(Succeed())
// 	})
// })

// // Test 8: Control Plane Recovery
// var _ = Describe("Control Plane Resilience", func() {
// 	It("Should automatically recover from control plane failures", func() {
// 		var controlPlaneNodes corev1.NodeList
// 		Eventually(func() error {
// 			return workloadClient.CoreV1().Nodes().List(
// 				context.TODO(),
// 				metav1.ListOptions{LabelSelector: "node-role.kubernetes.io/control-plane"},
// 			)
// 		}, timeout, interval).Should(Succeed())

// 		// Delete API server pod
// 		apiPods, err := workloadClient.CoreV1().Pods("kube-system").List(
// 			context.TODO(),
// 			metav1.ListOptions{LabelSelector: "component=kube-apiserver"},
// 		)
// 		Expect(err).NotTo(HaveOccurred())
// 		originalPod := apiPods.Items[0]
// 		Expect(workloadClient.CoreV1().Pods("kube-system").Delete(
// 			context.TODO(),
// 			originalPod.Name,
// 			metav1.DeleteOptions{},
// 		)).To(Succeed())

// 		// Verify pod recreation
// 		Eventually(func() bool {
// 			newPods, err := workloadClient.CoreV1().Pods("kube-system").List(
// 				context.TODO(),
// 				metav1.ListOptions{LabelSelector: "component=kube-apiserver"},
// 			)
// 			if err != nil {
// 				return false
// 			}
// 			for _, pod := range newPods.Items {
// 				if pod.UID != originalPod.UID && pod.Status.Phase == corev1.PodRunning {
// 					return true
// 				}
// 			}
// 			return false
// 		}, 5*time.Minute, 15*time.Second).Should(BeTrue())

// 		// Verify API server responsiveness
// 		Eventually(func() error {
// 			_, err := workloadClient.Discovery().ServerVersion()
// 			return err
// 		}, 3*time.Minute, 5*time.Second).Should(Succeed())
// 	})
// })

// Test 10: Resource Cleanup
// var _ = Describe("Cluster Teardown", func() {
// 	It("Should cleanly terminate cluster resources on deletion", func() {
// 		// Delete cluster
// 		cluster := &clusterv1.Cluster{
// 			ObjectMeta: metav1.ObjectMeta{
// 				Name:      clusterName,
// 				Namespace: namespace,
// 			},
// 		}
// 		Expect(managementClient.Delete(context.TODO(), cluster)).To(Succeed())

// 		// Verify cluster resource removal
// 		Eventually(func() bool {
// 			err := managementClient.Get(
// 				context.TODO(),
// 				ctrlclient.ObjectKey{Name: clusterName, Namespace: namespace},
// 				cluster,
// 			)
// 			return ctrlclient.IgnoreNotFound(err) == nil
// 		}, 30*time.Minute, 1*time.Minute).Should(BeTrue())

// 		// Verify dependent resources
// 		Eventually(func() int {
// 			secrets := &corev1.SecretList{}
// 			err := managementClient.List(
// 				context.TODO(),
// 				secrets,
// 				ctrlclient.InNamespace(namespace),
// 				ctrlclient.MatchingLabels{clusterv1.ClusterNameLabel: clusterName},
// 			)
// 			if err != nil {
// 				return -1
// 			}
// 			return len(secrets.Items)
// 		}, 15*time.Minute, 30*time.Second).Should(BeZero())

// 		// Verify cloud resources (AWS example)
// 		Eventually(func() int {
// 			// Implement cloud provider specific checks
// 			// Example for AWS:
// 			// loadBalancers, err := awsClient.DescribeLoadBalancers(...)
// 			// return len(loadBalancers)
// 			return 0
// 		}, 30*time.Minute, 2*time.Minute).Should(BeZero())
// 	})
// })

// Helper functions
func createNetworkTestPod(name, namespace string) *corev1.Pod {
	pod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Spec: corev1.PodSpec{
			Containers: []corev1.Container{{
				Name:    "test",
				Image:   "alpine:latest",
				Command: []string{"tail", "-f", "/dev/null"},
			}},
		},
	}
	createdPod, err := workloadClient.CoreV1().Pods(namespace).Create(context.TODO(), pod, metav1.CreateOptions{})
	Expect(err).NotTo(HaveOccurred())
	Eventually(func() corev1.PodPhase {
		p, _ := workloadClient.CoreV1().Pods(namespace).Get(context.TODO(), name, metav1.GetOptions{})
		return p.Status.Phase
	}, 2*time.Minute, 5*time.Second).Should(Equal(corev1.PodRunning))
	return createdPod
}

func createDNSTestPod() *corev1.Pod {
	pod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name: "dns-test",
		},
		Spec: corev1.PodSpec{
			Containers: []corev1.Container{{
				Name:    "dns-test",
				Image:   "alpine:latest",
				Command: []string{"tail", "-f", "/dev/null"},
			}},
		},
	}
	createdPod, err := workloadClient.CoreV1().Pods("default").Create(context.TODO(), pod, metav1.CreateOptions{})
	Expect(err).NotTo(HaveOccurred())
	Eventually(func() corev1.PodPhase {
		p, _ := workloadClient.CoreV1().Pods("default").Get(context.TODO(), "dns-test", metav1.GetOptions{})
		return p.Status.Phase
	}, 2*time.Minute, 5*time.Second).Should(Equal(corev1.PodRunning))
	return createdPod
}
